<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé€Ÿæº«æ§ - é›™äºº 3D è³½è»Šå°æ±º (Ultimate Edition)</title>
    <!-- å¼•å…¥ Three.js ç”¨æ–¼ 3D æ¸²æŸ“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Russo+One&family=Roboto:wght@400;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body { overflow: hidden; background-color: #000; font-family: 'Roboto', sans-serif; color: white; }

        /* UI å±¤ç´šç®¡ç† */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #game-canvas { position: fixed; top: 0; left: 0; z-index: 1; }
        
        /* ç…™ç« Canvas - ç§»åˆ°æœ€ä¸Šå±¤ (z-index: 300) */
        #fireworks { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 300; mix-blend-mode: screen; }

        /* ç™»å…¥ç•«é¢ */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0d0d2b 0%, #000000 100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            overflow-y: auto;
        }

        .title-text {
            font-family: 'Black Ops One', cursive;
            font-size: 4rem;
            background: linear-gradient(to right, #00f2ff, #eb00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.5);
            letter-spacing: 5px;
        }

        .setup-container {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 20px;
        }

        .player-setup {
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.1);
            width: 380px;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .player-setup:hover { transform: translateY(-5px); }
        .player-setup.p1:hover { border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
        .player-setup.p2:hover { border-color: #ff0055; box-shadow: 0 0 20px rgba(255, 0, 85, 0.3); }

        .player-setup h2 { 
            font-family: 'Russo One', sans-serif;
            margin-bottom: 20px; text-align: center; letter-spacing: 1px; 
        }
        .player-setup.p1 h2 { color: #00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        .player-setup.p2 h2 { color: #ff0055; text-shadow: 0 0 10px rgba(255,0,85,0.5); }

        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; font-size: 0.9rem; margin-bottom: 5px; color: #aaa; }
        .input-group input {
            width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #444;
            background: rgba(0,0,0,0.6); color: white; font-size: 1rem;
            transition: border-color 0.3s;
        }
        .player-setup.p1 input:focus { border-color: #00ffff; outline: none; }
        .player-setup.p2 input:focus { border-color: #ff0055; outline: none; }

        /* é ­åƒé¸æ“‡ */
        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        .avatar-option {
            font-size: 2.2rem;
            cursor: pointer;
            text-align: center;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s;
            filter: grayscale(0.7) opacity(0.7);
            user-select: none;
        }
        .avatar-option:hover { filter: grayscale(0) opacity(1); transform: scale(1.2); }
        .avatar-option.selected {
            background: rgba(255,255,255,0.2);
            filter: grayscale(0) opacity(1);
            box-shadow: 0 0 15px white;
            transform: scale(1.1);
        }

        .start-btn {
            margin-top: 30px;
            padding: 15px 60px;
            font-size: 2.2rem;
            font-family: 'Black Ops One', cursive;
            background: linear-gradient(90deg, #00f2ff, #eb00ff);
            border: none;
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
            box-shadow: 0 0 30px rgba(235, 0, 255, 0.5);
            transition: transform 0.2s;
            animation: pulse 2s infinite;
        }
        .start-btn:active { transform: scale(0.95); }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(235, 0, 255, 0.7); } 70% { box-shadow: 0 0 0 25px rgba(235, 0, 255, 0); } 100% { box-shadow: 0 0 0 0 rgba(235, 0, 255, 0); } }

        /* éŠæˆ²ä¸­ HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 30px;
            width: 100%;
        }
        .player-card {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            width: 350px;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            transform: skewX(-10deg); /* è³½è»Šé¢¨æ ¼å‚¾æ–œ */
        }
        .player-card > * { transform: skewX(10deg); /* å…§å®¹è½‰æ­£ */ }
        
        .player-card.p2 { border-color: #ff0055; text-align: right; }
        .player-card.p2 .info-row { flex-direction: row-reverse; }
        
        .info-row { display: flex; align-items: center; gap: 20px; margin-bottom: 15px; }
        .avatar-display { font-size: 3.5rem; filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); }
        .name-display { 
            font-family: 'Russo One', sans-serif;
            font-size: 1.8rem; 
            color: #fff; 
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .speed-meter { font-family: 'Black Ops One'; font-size: 3rem; color: #ffff00; text-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
        .unit { font-size: 1.2rem; color: #aaa; font-family: 'Russo One', sans-serif; }

        .progress-track {
            width: 100%; height: 25px; background: #222; border-radius: 12px; overflow: hidden;
            position: relative; border: 1px solid #555;
            box-shadow: inset 0 0 10px rgba(0,0,0,1);
        }
        .progress-fill {
            height: 100%; width: 0%; transition: width 0.5s ease-out;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            position: relative;
            box-shadow: 0 0 15px #00ffff;
        }
        .player-card.p2 .progress-fill { background: linear-gradient(90deg, #ff0055, #ff8800); box-shadow: 0 0 15px #ff0055; }
        
        .distance-text { 
            position: absolute; width: 100%; text-align: center; top: 2px; 
            line-height: 20px; font-size: 1rem; font-weight: bold; 
            text-shadow: 1px 1px 2px black, 0 0 5px black; 
            color: white; font-family: 'Russo One', sans-serif; z-index: 2;
        }

        /* ç²å‹ç•«é¢ - z-index 200 (å°æ–¼ç…™ç«) */
        #winner-overlay {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .winner-name {
            font-size: 7rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 50px #ffd700, 0 0 100px orange;
            animation: bounceIn 1s cubic-bezier(0.215, 0.610, 0.355, 1.000) both;
            font-family: 'Black Ops One', cursive;
            margin-bottom: 20px;
        }
        .win-subtitle { font-size: 2.5rem; margin-bottom: 40px; color: white; font-family: 'Russo One'; letter-spacing: 5px; }
        
        @keyframes bounceIn {
            0% { opacity: 0; transform: scale3d(.3, .3, .3); }
            20% { transform: scale3d(1.1, 1.1, 1.1); }
            40% { transform: scale3d(.9, .9, .9); }
            60% { opacity: 1; transform: scale3d(1.03, 1.03, 1.03); }
            80% { transform: scale3d(.97, .97, .97); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }
    </style>
</head>
<body>

    <!-- éŠæˆ²æ¸²æŸ“å±¤ -->
    <canvas id="game-canvas"></canvas>
    <!-- ç…™ç«å±¤ (æœ€é«˜) -->
    <canvas id="fireworks"></canvas>

    <!-- UI ä»‹é¢ -->
    <div id="login-screen">
        <div class="title-text">æ¥µé€Ÿæº«æ§è³½è»Š</div>
        
        <div class="setup-container">
            <!-- ç©å®¶ 1 è¨­å®š -->
            <div class="player-setup p1">
                <h2>ğŸ ç©å®¶ 1 (è—éšŠ)</h2>
                <div class="input-group">
                    <label>å§“å</label>
                    <input type="text" id="p1-name" placeholder="è¼¸å…¥åå­—" value="é–ƒé›»ä¿ ">
                </div>
                <div class="input-group">
                    <label>Google Sheet API URL (GAS)</label>
                    <input type="text" id="p1-url" placeholder="é€£çµç¶²å€">
                </div>
                <label style="color:#ccc; font-size:0.9rem;">é¸æ“‡è»Šæ‰‹</label>
                <div class="avatar-grid" id="p1-avatars">
                    <!-- 5ç”· (å¤šæ¨£åŒ–) -->
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ‘®â€â™‚ï¸')">ğŸ‘®â€â™‚ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ‘¨â€ğŸš€')">ğŸ‘¨â€ğŸš€</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ§›')">ğŸ§›</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ§™â€â™‚ï¸')">ğŸ§™â€â™‚ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ¤–')">ğŸ¤–</div>
                    <!-- 5å¥³ (å¤šæ¨£åŒ–) -->
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ‘©â€âš•ï¸')">ğŸ‘©â€âš•ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ•µï¸â€â™€ï¸')">ğŸ•µï¸â€â™€ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ¦¸â€â™€ï¸')">ğŸ¦¸â€â™€ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ§â€â™€ï¸')">ğŸ§â€â™€ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(1, 'ğŸ§Ÿâ€â™€ï¸')">ğŸ§Ÿâ€â™€ï¸</div>
                </div>
            </div>

            <!-- ç©å®¶ 2 è¨­å®š -->
            <div class="player-setup p2">
                <h2>ğŸ ç©å®¶ 2 (ç´…éšŠ)</h2>
                <div class="input-group">
                    <label>å§“å</label>
                    <input type="text" id="p2-name" placeholder="è¼¸å…¥åå­—" value="ç«ç„°å¥³">
                </div>
                <div class="input-group">
                    <label>Google Sheet API URL (GAS)</label>
                    <input type="text" id="p2-url" placeholder="é€£çµç¶²å€">
                </div>
                <label style="color:#ccc; font-size:0.9rem;">é¸æ“‡è»Šæ‰‹</label>
                <div class="avatar-grid" id="p2-avatars">
                    <!-- 5ç”· (å¤šæ¨£åŒ–) -->
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ¤ ')">ğŸ¤ </div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ¤¡')">ğŸ¤¡</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ‘¹')">ğŸ‘¹</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ‘½')">ğŸ‘½</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ¤´')">ğŸ¤´</div>
                    <!-- 5å¥³ (å¤šæ¨£åŒ–) -->
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ‘©â€ğŸ¤')">ğŸ‘©â€ğŸ¤</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ‘¸')">ğŸ‘¸</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ§™â€â™€ï¸')">ğŸ§™â€â™€ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ§šâ€â™€ï¸')">ğŸ§šâ€â™€ï¸</div>
                    <div class="avatar-option" onclick="selectAvatar(2, 'ğŸ§â€â™€ï¸')">ğŸ§â€â™€ï¸</div>
                </div>
            </div>
        </div>

        <button class="start-btn" onclick="startGame()">å•Ÿå‹•å¼•æ“ START</button>
        <div style="margin-top:15px; color: #888; font-size: 0.8rem;">*è«‹ç¢ºä¿ GAS ç¶²å€æ¬Šé™å·²è¨­ç‚ºå…¬é–‹ | æ”¯æ´æ¨¡æ“¬æ¨¡å¼</div>
    </div>

    <!-- éŠæˆ²ä¸­ä»‹é¢ -->
    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <!-- P1 HUD -->
            <div class="player-card p1">
                <div class="info-row">
                    <div class="avatar-display" id="hud-p1-avatar">ğŸ˜</div>
                    <div>
                        <div class="name-display" id="hud-p1-name">Player 1</div>
                        <div class="speed-meter"><span id="hud-p1-speed">0</span> <span class="unit">Temp</span></div>
                    </div>
                </div>
                <div class="progress-track">
                    <div class="progress-fill" id="hud-p1-bar"></div>
                    <div class="distance-text" id="hud-p1-dist">0 / 200 Pts</div>
                </div>
            </div>

            <!-- P2 HUD -->
            <div class="player-card p2">
                <div class="info-row">
                    <div class="avatar-display" id="hud-p2-avatar">ğŸ˜</div>
                    <div>
                        <div class="name-display" id="hud-p2-name">Player 2</div>
                        <div class="speed-meter"><span id="hud-p2-speed">0</span> <span class="unit">Temp</span></div>
                    </div>
                </div>
                <div class="progress-track">
                    <div class="progress-fill" id="hud-p2-bar"></div>
                    <div class="distance-text" id="hud-p2-dist">0 / 200 Pts</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ç²å‹ç•«é¢ -->
    <div id="winner-overlay">
        <div class="winner-name" id="winner-text">PLAYER WINS!</div>
        <div class="win-subtitle">ğŸ† ç‹è€…èª•ç”Ÿ ğŸ†</div>
        <button class="start-btn" style="font-size: 1.5rem; padding: 10px 30px;" onclick="location.reload()">é‡æ–°æ¯”è³½</button>
    </div>

    <script>
        // === éŠæˆ²å…¨åŸŸè®Šæ•¸ ===
        let gameState = 'setup'; 
        let scene, camera, renderer;
        let road, gridHelper;
        let environmentObjects = []; // å­˜æ”¾è·¯é‚Šæ™¯ç‰©
        const players = [
            { id: 1, name: '', url: '', avatar: '', speed: 0, distance: 0, mesh: null, color: 0x00ffff, wheelRot: 0 },
            { id: 2, name: '', url: '', avatar: '', speed: 0, distance: 0, mesh: null, color: 0xff0055, wheelRot: 0 }
        ];
        const WINNING_DISTANCE = 200;
        let fetchInterval;
        
        // éŸ³æ•ˆç’°å¢ƒ
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let engineOscillators = [null, null];
        let bgmInterval = null;

        // === 1. è¨­å®šèˆ‡åˆå§‹åŒ– ===
        function selectAvatar(pid, emoji) {
            const pIndex = pid - 1;
            players[pIndex].avatar = emoji;
            
            // UI æ›´æ–°
            const container = document.getElementById(`p${pid}-avatars`);
            const opts = container.getElementsByClassName('avatar-option');
            for(let opt of opts) {
                if(opt.textContent === emoji) opt.classList.add('selected');
                else opt.classList.remove('selected');
            }
        }

        // é è¨­é¸æ“‡
        selectAvatar(1, 'ğŸ‘®â€â™‚ï¸');
        selectAvatar(2, 'ğŸ¤ ');

        function startGame() {
            if(audioCtx.state === 'suspended') audioCtx.resume();

            players[0].name = document.getElementById('p1-name').value || 'Player 1';
            players[0].url = document.getElementById('p1-url').value;
            players[1].name = document.getElementById('p2-name').value || 'Player 2';
            players[1].url = document.getElementById('p2-url').value;

            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';

            updateHUDStatic();
            init3DScene();
            
            gameState = 'playing';
            startDataFetching();
            startEngineSound();
            startRetroBGM();
            animate();
        }

        function updateHUDStatic() {
            document.getElementById('hud-p1-name').innerText = players[0].name;
            document.getElementById('hud-p1-avatar').innerText = players[0].avatar;
            document.getElementById('hud-p2-name').innerText = players[1].name;
            document.getElementById('hud-p2-avatar').innerText = players[1].avatar;
        }

        // === 2. Three.js 3D å ´æ™¯ (é…·ç‚«å‡ç´šç‰ˆ) ===
        function init3DScene() {
            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding; // æ›´å¥½çš„é¡è‰²

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.02); // éœ§æ°£ç¨å¾®æ¿ƒä¸€é»

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 18);
            camera.lookAt(0, 0, -15);

            // ç‡ˆå…‰ - å¢åŠ æˆ²åŠ‡æ€§
            const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // èšå…‰ç‡ˆç…§è»Š
            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 15, 0);
            spotLight.angle = Math.PI / 4;
            scene.add(spotLight);

            // åœ°é¢ (é“è·¯)
            const roadGeo = new THREE.PlaneGeometry(30, 2000);
            const roadMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.8 
            });
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -900;
            road.receiveShadow = true;
            scene.add(road);

            // åœ°é¢ç¶²æ ¼ (éœ“è™¹è³½åšé¢¨)
            gridHelper = new THREE.GridHelper(60, 600, 0x00ffff, 0x220044);
            gridHelper.position.z = -100;
            gridHelper.scale.z = 5;
            scene.add(gridHelper);

            // å»ºç«‹é…·ç‚«è³½è»Š
            players[0].mesh = createSportCar(players[0].color, -5);
            players[1].mesh = createSportCar(players[1].color, 5);
            scene.add(players[0].mesh);
            scene.add(players[1].mesh);
            
            // ç”Ÿæˆç’°å¢ƒæ™¯ç‰©
            initEnvironment();
        }

        function createSportCar(colorHex, xPos) {
            const carGroup = new THREE.Group();

            // 1. åº•ç›¤ (ä½è¶´å¯¬é«”)
            const chassisGeo = new THREE.BoxGeometry(3, 0.5, 6);
            const paintMat = new THREE.MeshPhysicalMaterial({
                color: colorHex,
                metalness: 0.6,
                roughness: 0.2,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            const chassis = new THREE.Mesh(chassisGeo, paintMat);
            chassis.position.y = 0.5;
            chassis.castShadow = true;
            carGroup.add(chassis);

            // 2. é§•é§›è‰™ (æµç·šå‹)
            const cabinGeo = new THREE.BoxGeometry(1.8, 0.6, 2.5);
            const cabinMat = new THREE.MeshPhysicalMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 1.0, -0.5);
            carGroup.add(cabin);

            // 3. å¼•æ“è“‹é€²æ°£å£
            const intakeGeo = new THREE.BoxGeometry(1.5, 0.2, 1.5);
            const intake = new THREE.Mesh(intakeGeo, paintMat);
            intake.position.set(0, 0.8, 1.5);
            carGroup.add(intake);

            // 4. å°¾ç¿¼ (å¤§å°¾ç¿¼)
            const spoilerSupportGeo = new THREE.BoxGeometry(2.5, 0.1, 0.5);
            const spoilerWingGeo = new THREE.BoxGeometry(3.5, 0.1, 1);
            const spoilerSupport = new THREE.Mesh(spoilerSupportGeo, paintMat);
            spoilerSupport.position.set(0, 1.0, -2.8);
            const spoilerWing = new THREE.Mesh(spoilerWingGeo, paintMat);
            spoilerWing.position.set(0, 1.3, -2.8);
            carGroup.add(spoilerSupport);
            carGroup.add(spoilerWing);

            // 5. è¼ªèƒ (4å€‹)
            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.6, 24);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
            
            const wheelPositions = [
                {x: -1.6, z: 1.8}, {x: 1.6, z: 1.8}, // å‰è¼ª
                {x: -1.6, z: -2.0}, {x: 1.6, z: -2.0} // å¾Œè¼ª
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.6, pos.z);
                wheel.castShadow = true;
                // åŠ ä¸€å€‹è¼ªæ¡†
                const rimGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.62, 8);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
                const rim = new THREE.Mesh(rimGeo, rimMat);
                rim.rotation.z = Math.PI / 2;
                rim.position.set(pos.x, 0.6, pos.z);
                
                carGroup.add(wheel);
                carGroup.add(rim);
            });

            // 6. å°¾ç„° (ç™¼å…‰çƒ)
            const flameGeo = new THREE.SphereGeometry(0.4);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const flame1 = new THREE.Mesh(flameGeo, flameMat);
            flame1.position.set(-0.8, 0.6, -3.1);
            flame1.name = "flame1";
            const flame2 = new THREE.Mesh(flameGeo, flameMat);
            flame2.position.set(0.8, 0.6, -3.1);
            flame2.name = "flame2";
            carGroup.add(flame1);
            carGroup.add(flame2);

            carGroup.position.set(xPos, 0, 0);
            return carGroup;
        }

        // ç’°å¢ƒç”Ÿæˆ (çŸ³é ­ã€æ¨¹æœ¨ã€å»ºç¯‰)
        function initEnvironment() {
            // ç°¡å–®çš„å¹¾ä½•é«”
            const treeGeo = new THREE.ConeGeometry(2, 8, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x00aa44, flatShading: true });
            
            const rockGeo = new THREE.DodecahedronGeometry(1.5);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555, flatShading: true });
            
            const buildGeo = new THREE.BoxGeometry(4, 15, 4);
            const buildMat = new THREE.MeshStandardMaterial({ color: 0x222244 });

            // ç”Ÿæˆ 50 å€‹ç‰©ä»¶
            for(let i=0; i<50; i++) {
                let mesh;
                const type = Math.random();
                if(type < 0.4) { // æ¨¹
                    mesh = new THREE.Mesh(treeGeo, treeMat);
                    mesh.position.y = 4;
                } else if (type < 0.7) { // çŸ³é ­
                    mesh = new THREE.Mesh(rockGeo, rockMat);
                    mesh.position.y = 1;
                } else { // å»ºç¯‰
                    mesh = new THREE.Mesh(buildGeo, buildMat);
                    mesh.position.y = 7.5;
                    // å»ºç¯‰åŠ é»çª—æˆ¶å…‰
                    const winGeo = new THREE.BoxGeometry(4.1, 1, 1);
                    const winMat = new THREE.MeshBasicMaterial({color: 0xffff00});
                    const win = new THREE.Mesh(winGeo, winMat);
                    win.position.y = 4;
                    mesh.add(win);
                }

                // éš¨æ©Ÿä½ç½® (é è™•)
                // X: é“è·¯å…©æ— (-50 ~ -15) æˆ– (15 ~ 50)
                const side = Math.random() > 0.5 ? 1 : -1;
                const x = side * (15 + Math.random() * 35);
                // Z: éš¨æ©Ÿåˆ†å¸ƒåœ¨å‰æ–¹ -200 åˆ° -10 ä¹‹é–“
                const z = - Math.random() * 400;

                mesh.position.x = x;
                mesh.position.z = z;
                scene.add(mesh);
                environmentObjects.push(mesh);
            }
        }

        // === 3. æ•¸æ“šèˆ‡é‚è¼¯æ§åˆ¶ ===
        function startDataFetching() {
            fetchPlayerData();
            fetchInterval = setInterval(fetchPlayerData, 1500);
        }

        async function fetchPlayerData() {
            if(gameState === 'finished') return;

            players.forEach(async (p, index) => {
                if(gameState === 'finished') return;

                let newSpeed = 0;
                const targetUrl = p.url ? p.url.trim() : '';

                if (!targetUrl) {
                    // æ¨¡æ“¬æ•¸æ“š
                    newSpeed = Math.floor(Math.random() * 25) + 20;
                } else {
                    try {
                        const response = await fetch(targetUrl);
                        if (!response.ok) throw new Error("Network response was not ok");
                        const result = await response.json();
                        if (result.status === 'success' && result.data && result.data.length > 0) {
                            const lastData = result.data[result.data.length - 1];
                            newSpeed = parseFloat(lastData['tempå€¼']) || 0;
                        }
                    } catch (e) {
                        newSpeed = Math.floor(Math.random() * 25) + 20;
                    }
                }

                if(gameState === 'finished') return;

                p.speed = newSpeed; 
                p.distance += newSpeed; 

                updateHUD(index);
                checkWin(index);
            });
        }

        function updateHUD(pIndex) {
            const p = players[pIndex];
            const id = pIndex + 1;
            
            document.getElementById(`hud-p${id}-speed`).innerText = Math.floor(p.speed);
            const percent = Math.min((p.distance / WINNING_DISTANCE) * 100, 100);
            document.getElementById(`hud-p${id}-bar`).style.width = `${percent}%`;
            document.getElementById(`hud-p${id}-dist`).innerText = `${p.distance.toFixed(1)} / ${WINNING_DISTANCE} Pts`;

            // å¼•æ“è²èª¿è®Š
            if(engineOscillators[pIndex]) {
                const baseFreq = 60 + (p.speed * 1.5); 
                engineOscillators[pIndex].frequency.setTargetAtTime(baseFreq, audioCtx.currentTime, 0.1);
            }
        }

        function checkWin(pIndex) {
            if (gameState === 'finished') return;
            if (players[pIndex].distance >= WINNING_DISTANCE) {
                endGame(pIndex);
            }
        }

        function endGame(winnerIndex) {
            gameState = 'finished';
            if (fetchInterval) clearInterval(fetchInterval);
            stopEngineSound();
            stopBackgroundMusic(); 
            playVictoryFanfare(); 

            const overlay = document.getElementById('winner-overlay');
            const winnerText = document.getElementById('winner-text');
            overlay.style.display = 'flex';
            winnerText.innerText = `${players[winnerIndex].name} ç²å‹!`;
            winnerText.style.color = players[winnerIndex].color === 0x00ffff ? '#00ffff' : '#ff0055';

            startFireworks();
        }

        // === 4. æ¸²æŸ“å¾ªç’° ===
        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'playing' || gameState === 'finished') {
                const maxSpeed = Math.max(players[0].speed, players[1].speed);
                const displaySpeed = maxSpeed > 0 ? maxSpeed : 0;
                const moveSpeed = displaySpeed * 0.2; // ç’°å¢ƒç§»å‹•é€Ÿåº¦

                // 1. åœ°æ¿ç§»å‹•
                gridHelper.position.z += moveSpeed;
                if(gridHelper.position.z > 0) gridHelper.position.z = -100;

                // 2. ç’°å¢ƒæ™¯ç‰©ç§»å‹• (å¾ªç’°)
                environmentObjects.forEach(obj => {
                    obj.position.z += moveSpeed;
                    if(obj.position.z > 20) { // è¶…éç›¸æ©Ÿä½ç½®
                        obj.position.z = -400; // é‡ç½®åˆ°é è™•
                        // éš¨æ©Ÿæ›é‚Š
                        const side = Math.random() > 0.5 ? 1 : -1;
                        obj.position.x = side * (15 + Math.random() * 35);
                    }
                });

                // 3. è»Šå­å‹•ç•«
                players.forEach(p => {
                    if(p.mesh) {
                        // æŒ¯å‹•
                        p.mesh.position.y = (Math.random() * 0.05) * (p.speed/50);
                        
                        // å°¾ç„°
                        const f1 = p.mesh.getObjectByName("flame1");
                        const f2 = p.mesh.getObjectByName("flame2");
                        if(f1 && f2) {
                            const scale = 1 + Math.random() * (p.speed / 15);
                            f1.scale.set(scale, scale, scale);
                            f2.scale.set(scale, scale, scale);
                            
                            // é¡è‰²è®ŠåŒ–
                            const hue = (Math.random() * 0.1) + 0.05; // æ©™é»ƒè‰²
                            f1.material.color.setHSL(hue, 1, 0.5);
                        }

                        // å‰å¾Œç§»å‹• (åæ˜ åˆ†æ•¸å·®è·)
                        const opponentIndex = p.id === 1 ? 1 : 0;
                        const diff = p.distance - players[opponentIndex].distance;
                        let targetZ = Math.max(-6, Math.min(8, diff * 0.05));
                        p.mesh.position.z += (targetZ - p.mesh.position.z) * 0.05;
                        
                        // è½‰å½å‚¾æ–œæ•ˆæœ (å‡è£åœ¨ä¿®æ­£æ–¹å‘)
                        p.mesh.rotation.z = Math.sin(Date.now() * 0.005) * 0.05;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        // === 5. éŸ³æ•ˆç³»çµ± ===
        function startEngineSound() {
            players.forEach((p, idx) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                // ä½¿ç”¨ä½é »é‹¸é½’æ³¢æ¨¡æ“¬å¼•æ“
                osc.type = 'sawtooth';
                osc.frequency.value = 60;
                // LFO æ¨¡æ“¬å¼•æ“æŠ–å‹•
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 10;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 10;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start();

                gain.gain.value = 0.03;
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                engineOscillators[idx] = osc;
            });
        }

        function stopEngineSound() {
            engineOscillators.forEach(osc => { if(osc) try { osc.stop(); } catch(e){} });
        }

        // BGM
        let bgmNoteTime = 0;
        let bgmNoteIndex = 0;
        const tempo = 140; 
        const scheduleAheadTime = 0.1;

        function startRetroBGM() {
            bgmNoteTime = audioCtx.currentTime;
            bgmNoteIndex = 0;
            bgmInterval = setInterval(scheduler, 25);
        }

        function stopBackgroundMusic() {
            if(bgmInterval) clearInterval(bgmInterval);
        }

        function scheduler() {
            while (bgmNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                playBGMNote(bgmNoteTime, bgmNoteIndex);
                advanceNote();
            }
        }

        function advanceNote() {
            const secondsPerBeat = 60.0 / tempo;
            bgmNoteTime += 0.25 * secondsPerBeat;
            bgmNoteIndex++;
        }

        function playBGMNote(time, index) {
            const beat = index % 16;
            // Bass (Square)
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bassOsc.type = 'square';
            bassOsc.connect(bassGain);
            bassGain.connect(audioCtx.destination);

            // F-Zero Style Bassline (roughly)
            let freq = 0;
            // E2 baseline
            if([0, 2, 4, 6].includes(beat)) freq = 82.41; // E2
            if([8, 10].includes(beat)) freq = 98.00; // G2
            if([12, 14].includes(beat)) freq = 110.00; // A2

            if(freq > 0) {
                bassOsc.frequency.value = freq;
                bassGain.gain.setValueAtTime(0.15, time);
                bassGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                bassOsc.start(time);
                bassOsc.stop(time + 0.15);
            }
            
            // Hi-hat
            if(beat % 2 !== 0) playNoise(time);
        }

        function playNoise(time) {
            const bufferSize = audioCtx.sampleRate * 0.05;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.value = 0.08;
            noise.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start(time);
        }

        function playVictoryFanfare() {
            const now = audioCtx.currentTime;
            const notes = [
                {f: 523.25, t: 0.0}, {f: 659.25, t: 0.1}, {f: 783.99, t: 0.2}, 
                {f: 1046.50, t: 0.3, l: 2.0}
            ];
            notes.forEach(n => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = n.f;
                const start = now + n.t;
                gain.gain.setValueAtTime(0, start);
                gain.gain.linearRampToValueAtTime(0.3, start + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, start + (n.l || 0.2));
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(start);
                osc.stop(start + (n.l || 0.2) + 0.1);
            });
        }

        // === 6. ç…™ç«ç³»çµ± ===
        const fwCanvas = document.getElementById('fireworks');
        const fwCtx = fwCanvas.getContext('2d');
        let fireworks = [];

        function startFireworks() {
            fwCanvas.width = window.innerWidth;
            fwCanvas.height = window.innerHeight;
            fwCtx.globalCompositeOperation = 'lighter';
            fireworkLoop();
        }

        function fireworkLoop() {
            if(gameState !== 'finished') return;
            requestAnimationFrame(fireworkLoop);
            
            fwCtx.globalCompositeOperation = 'destination-out';
            fwCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            fwCtx.fillRect(0, 0, fwCanvas.width, fwCanvas.height);
            fwCtx.globalCompositeOperation = 'lighter';

            if (Math.random() < 0.08) fireworks.push(new Firework());
            fireworks = fireworks.filter(p => p.update());
            fireworks.forEach(p => p.draw());
        }

        class Firework {
            constructor() {
                this.x = Math.random() * fwCanvas.width;
                this.y = fwCanvas.height;
                this.targetY = Math.random() * (fwCanvas.height / 2);
                this.speed = 10 + Math.random() * 5;
                this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                this.vx = Math.cos(this.angle) * this.speed;
                this.vy = Math.sin(this.angle) * this.speed;
                this.exploded = false;
                this.particles = [];
                this.hue = Math.random() * 360;
            }

            update() {
                if (!this.exploded) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.15;
                    if (this.vy >= 0 || this.y < this.targetY) this.explode();
                } else {
                    this.particles.forEach(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.05;
                        p.alpha -= 0.02;
                    });
                    this.particles = this.particles.filter(p => p.alpha > 0);
                }
                return !this.exploded || this.particles.length > 0;
            }

            explode() {
                this.exploded = true;
                playExplosionSound();
                
                // é–ƒå…‰
                fwCtx.beginPath();
                fwCtx.arc(this.x, this.y, 30, 0, Math.PI*2);
                fwCtx.fillStyle = `hsla(${this.hue}, 100%, 80%, 0.8)`;
                fwCtx.fill();

                for (let i = 0; i < 60; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 8;
                    this.particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        alpha: 1, 
                        color: `hsl(${this.hue}, 100%, ${50 + Math.random()*30}%)`
                    });
                }
            }

            draw() {
                if (!this.exploded) {
                    fwCtx.beginPath();
                    fwCtx.arc(this.x, this.y, 4, 0, Math.PI*2);
                    fwCtx.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
                    fwCtx.fill();
                } else {
                    this.particles.forEach(p => {
                        fwCtx.save();
                        fwCtx.globalAlpha = p.alpha;
                        fwCtx.fillStyle = p.color;
                        fwCtx.beginPath();
                        fwCtx.arc(p.x, p.y, 3, 0, Math.PI*2);
                        fwCtx.fill();
                        fwCtx.restore();
                    });
                }
            }
        }

        function playExplosionSound() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            if(fwCanvas) {
                fwCanvas.width = window.innerWidth;
                fwCanvas.height = window.innerHeight;
            }
        });

    </script>
</body>
</html>
